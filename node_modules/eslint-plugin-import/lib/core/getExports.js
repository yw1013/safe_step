'use strict';

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Map = require('babel-runtime/core-js/map')['default'];

var _Set = require('babel-runtime/core-js/set')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _parse2 = require('./parse');

var _parse3 = _interopRequireDefault(_parse2);

var _resolve = require('./resolve');

var _resolve2 = _interopRequireDefault(_resolve);

var _resolve3 = require('resolve');

var _ignore = require('./ignore');

var _ignore2 = _interopRequireDefault(_ignore);

var exportCache = new _Map();

var ExportMap = (function () {
  function ExportMap(settings) {
    _classCallCheck(this, ExportMap);

    this.settings = settings;
    this.named = new _Set();

    this.errors = [];
  }

  _createClass(ExportMap, [{
    key: 'resolveReExport',
    value: function resolveReExport(node, base) {
      var remotePath = _resolve2['default'].relative(node.source.value, base, this.settings);
      if (remotePath == null) return null;

      return ExportMap['for'](remotePath, this.settings);
    }
  }, {
    key: 'captureDefault',
    value: function captureDefault(n) {
      if (n.type !== 'ExportDefaultDeclaration') return;
      this.named.add('default');
    }

    /**
     * capture all named exports from remote module.
     *
     * returns null if this node wasn't an ExportAllDeclaration
     * returns false if it was not resolved
     * returns true if it was resolved + parsed
     *
     * @param  {node} n
     * @param  {string} path - the path of the module currently parsing
     * @return {boolean?}
     */
  }, {
    key: 'captureAll',
    value: function captureAll(n, path) {
      if (n.type !== 'ExportAllDeclaration') return null;

      var remoteMap = this.resolveReExport(n, path);
      if (remoteMap == null) return false;

      remoteMap.named.forEach((function (name) {
        this.named.add(name);
      }).bind(this));

      return true;
    }
  }, {
    key: 'captureNamedDeclaration',
    value: function captureNamedDeclaration(n, path) {
      if (n.type !== 'ExportNamedDeclaration') return;

      // capture declaration
      if (n.declaration != null) {
        switch (n.declaration.type) {
          case 'FunctionDeclaration':
          case 'ClassDeclaration':
            this.named.add(n.declaration.id.name);
            break;
          case 'VariableDeclaration':
            n.declaration.declarations.forEach((function (d) {
              this.named.add(d.id.name);
            }).bind(this));
            break;
        }
      }

      // capture specifiers
      var remoteMap = undefined;
      if (n.source) remoteMap = this.resolveReExport(n, path);

      n.specifiers.forEach((function (s) {
        if (s.type === 'ExportDefaultSpecifier') {
          // don't add it if it is not present in the exported module
          if (!remoteMap || !remoteMap.hasDefault) return;
        }

        this.named.add(s.exported.name);
      }).bind(this));
    }
  }, {
    key: 'hasDefault',
    get: function get() {
      return this.named.has('default');
    }
  }, {
    key: 'hasNamed',
    get: function get() {
      return this.named.size > (this.hasDefault ? 1 : 0);
    }
  }], [{
    key: 'get',
    value: function get(source, context) {
      // no use trying to parse core modules
      if ((0, _resolve3.isCore)(source)) return null;

      var path = (0, _resolve2['default'])(source, context);
      if (path == null || (0, _ignore2['default'])(path, context)) return null;

      return ExportMap['for'](path, context.settings);
    }
  }, {
    key: 'for',
    value: function _for(path, settings) {
      var exportMap = exportCache.get(path);
      if (exportMap != null) return exportMap;

      exportMap = ExportMap.parse(path, settings);

      exportCache.set(path, exportMap);

      // Object.freeze(exportMap)
      // Object.freeze(exportMap.named)

      return exportMap;
    }
  }, {
    key: 'parse',
    value: function parse(path, settings) {
      var m = new ExportMap(settings);

      try {
        var ast = (0, _parse3['default'])(path, settings);
      } catch (err) {
        m.errors.push(err);
        return m; // can't continue
      }

      ast.body.forEach(function (n) {
        m.captureDefault(n);
        m.captureAll(n, path);
        m.captureNamedDeclaration(n, path);
      });

      return m;
    }
  }]);

  return ExportMap;
})();

exports['default'] = ExportMap;
module.exports = exports['default'];